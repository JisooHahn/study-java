# study-java

## Java-Study

JAVA - 프로그래밍 언어<br>

-   프로그래밍 언어는 개발자와 운영체제가 소통하기 위한 언어이다.

소스코드<br>

-   명령어를 작성해 놓은 것.<br>
    개발자와 운영체제가 소통할 것을 글로 작성해 놓은 것.

소스파일(.java)<br>

-   소스코드를 작성해 놓은 파일

컴파일<br>

-   사람의 언어를 컴퓨터 언어로 바꿔주는 작업.

컴파일러<br>

-   컴파일을 해주는 프로그램 또는 명령어<br>
    컴파일러는 위에서 아래로, 좌에서 우로 번역한다.

프로그램<br>

-   소스코드로 잘 짜여진 틀.

콘솔<br>

-   개발자와 운영체제가 소통한 결과를 보여주는 창.

▶ 일반 프로그램<br>

프로그램<br>

-   OS(운영체제): 하드웨어에 적절한 전기신호를 흘려주는 역할.
    하드웨어

▶ JAVA 프로그램<br>

JAVA 프로그램

-   JVM: JAVA 프로그램을 OS에 맞게 변환해준다.
-   OS(운영체제): 하드웨어에 적절한 전기신호를 흘려주는 역할. 하드웨어

-이식성이 좋다.

---

JVM(Java Vritual Machine)

-   JAVA 프로그램을 실행해 줌.

JRE(Java Runtime Environment)

-   JVM을 생성하며, 실행할 때 필요한 라이브러리 파일들을 가지고 있다.

JDK(Java Development Kit)

-   JRE 외에 개발에 필요한 도구들을 가지고 있다.<br>
    컴파일 명령어와 실행 명령어를 담고 있다.

---

> JDK 설치

    https://drive.google.com/file/d/1bsLuMXWQ-yg50m4SNToucnhEBMLSg6He/view?usp=drive_link

> IDE 설치

    - 이클립스
    	https://drive.google.com/file/d/18qYUbfdkXWrX0hbSnvFOuihh9MXI_k7j/view?usp=drive_link

---

#### 기본 구조

    프로젝트
    	패키지
    		클래스
    			메소드
    				소스코드

---

#### 출력 메소드

    1. print(): 마지막에 자동으로 줄바꿈되지 않고 아래 문장과 이어서 출력된다.
    2. println(): 마지막에 자동으로 줄바꿈된다.
    3. printf()

출력 메소드를 사용하는 이유<br>
데이터를 확인하기 위해서 사용하는 도구이다.<br>
오류를 구체화하기 위해 사용하는 도구이다.<br>
즉, 출력 메소드는 개발자를 위한 도구이다.

    A 코드
    B 코드
    C 코드
    D 코드

오류 발생시 어떤 라인에서 발생했는 지 알 수 없다.

    A 코드
    System.out.println("A")
    B 코드
    System.out.println("B")
    C 코드
    System.out.println("C")
    D 코드
    System.out.println("D")

C가 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에 D 코드에 문제가 발생한 것으로 판단된다.

---

#### 변수

변수는 저장공간이다.

| x        | =      | 10       |
| -------- | ------ | -------- |
| 저장공간 | 대입   | 값(상수) |
| 이름     | 연산자 |          |

#### 자료형(type)

자료형은 저장공간의 종류이다.

| 자료형 | type   | byte | 값                                 |
| ------ | ------ | ---- | ---------------------------------- |
| 정수형 | byte   | 1    | 4, 1, -12, 10, ...                 |
|        | short  | 2    | 9, 150, -55 ...                    |
|        | int    | 4    | 1235, 48916, -2147483648, ...      |
|        | long   | 8    | 15161848964L, -489415L, ...        |
| 실수형 | float  | 4    | 32.12F, 182.2341F, ...             |
|        | double | 8    | 32.12, 182.2341, ...               |
| 문자형 | char   | 2    | 'A', '0', '안', ...                |
| 문자열 | String | ???  | "ABC", "12.52", "123", "안녕", ... |

#### 변수의 선언

자료형 변수명 = 초기값; ◀ 초기화<br>
자료형 변수명;

    예)
    int x = 10;
    x라는 이름의 정수형 저장공간이 할당(allocation)되고 그 안에 10이 들어간다.

#### 변수의 초기값

```
정수: 0
실수: 0.0
문자: ' '
문자열: "", null
```

#### 변수의 사용

저장공간의 확인 단계<br>
1단계: 자료형을 확인한다.<br>
2단계: 대입 연산자를 확인한다.

    int data = 10;	// 저장공간
    data + 9;		// 값
    data = data + 99	// 저장공간, 값

#### 변수 선언 시 주의사항

1. 같은 이름의 변수로 선언할 수 없다.
2. 초기화를 해준다.
3. 되도록 선언부에 한꺼번에 선언한다(영역 상단).

#### 변수명 주의사항

1.  문자로 시작해야 한다.
2.  특수문자를 사용할 수 없다. 단, \_는 허용한다.
3.  소문자로 시작한다.
4.  공백을 사용할 수 없다.
    good boy
    good_boy: 언더바 표기법
    goodBoy: 카멜 표기법
5.  되도록 한글을 사용하지 않는다.
6.  명사로 사용한다.
7.  뜻이 있는 단어를 사용한다.

        a, b, c, d, e, f, ... (X)
        number, num, data, age, name, ... (O)

#### 변수를 사용하는 이유

1. 반복되는 값을 쉽게 관리하기 위해서
2. 의미 없는 값을 하나의 정보로 만들기 위해서(자료구조)

---

#### 상수

-항상 그대로인 수.<br>
값을 변경할 수 없도록 한다.

`final 자료형 상수명 = 값;`

#### 상수를 사용하는 이유

-   값에 의미부여를 하기 위해서

---

#### 형변환

-   자동 형변환<br>
    정수 + 정수 = 정수<br>
    정수 + 실수 = 실수<br>
    정수 + 문자 = 정수

```
3 + 0.0 = 3.0
10 / 3 = 3
10 % 3 = 1
'A' + 3 = 68
```

-   강제 형변환

```
(자료형)값
(double)3
```

#### 문자열 형변환

1. 다른 자료형을 문자열로<br>
   문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.

2. 문자열을 다른 자료형으로<br>
   일반 자료형은 일반 자료형끼리만 형변환이 가능하다.<br>
   문자열 타입은 클래스 타입이므로, 일반 자료형의 클래스 타입의 도움을 받아야 한다.

```
Integer.parseInt("") => 문자열에서 변환(추출)된 정수
Double.parseDouble("") => 문자열에서 변환(추출)된 실수
```

---

#### 배열:

저장공간의 나열

1. 변수를 여러 개 선언하면 이름도 여러 개 생긴다.<br>
   이 때 각 저장공간을 관리하기 불편하다.<br>
   따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고, 이름도 한 개이기 때문에
   관리하기 편하다.
2. 규칙성이 없는 값에 규칙성을 부여하기 위해서

#### 배열의 선언

자료형[] 배열명 = {값1, 값2, ... }; // 어떤 값을 넣을지 알 때 사용한다.<br>
자료형[] 배열명 = new 자료형[칸수]; // 어떤 값을 넣을지는 모르나, 몇 칸 만들지는 알 때 사용한다.<br>
자료형[] 배열명 = null; // 어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용한다.

```
※ new: Heap 메모리에 할당, 초기값으로 자동 초기화
※ null: 주소의 초기값, 어떤 주소를 넣을지 모를 때 작성하는 값
※ 자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적 배열만 존재한다.
```

#### 배열의 구조

`int[] arData = {3, 5, 1, 2, 8};`

arData라는 이름의 저장공간 한 개 만들어지며, <br>
여기에는 한 개의 값만 담을 수 있다.<br>
<br>
5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다.<br>
5칸의 저장공간 중 첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며,<br>
다음 주소에 접근하기 위해서는 + n을 한다.<br>
<br>
예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며, <br>
\*(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다.<br>
JAVA에서는 직접 주소에 접근하는 연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용한다.<br>
arData[2]로 사용한다. 각각의 방 번호는 index라고 부르며, 시작주소를 가지고 있기 때문에
인덱스 번호는 항상 0부터 시작된다.

#### length

-   배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.<br>
    `배열명.length`

#### 배열의 사용

    int[] arData = new int[5];		    // 저장공간
    arData[0] = 120;			        // 저장공간
    arData[0] + 9;			            // 값
    System.out.println(arData);		    // 주소값
    arData[2] = arData[0] + arData[1];	// 저장공간, 값
    System.out.println(arData[5]);		// 오류

---

#### 2차원 배열:

배열 안에 배열<br><br>
1차원 배열을 여러 개 선언하면, 관리하기 어렵다.<br>
2차원 배열을 한 번만 선언하자!

※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

#### 2차원 배열 선언

```
자료형[][] 배열명 = {{값1, 값2, ...}, {값3, 값4, ...}};
자료형[][] 배열명 = new 자료형[행][열];
자료형[][] 배열명 = null;
```

```
    int[][] arrData = new int[2][3];

    □		arrData		arrData.length: 행의 길이
    □□		arrData[행]	arrData[행].length: 열의 길이
    □□□ □□□	arrData[행][열]
```

---

### 클래스(반)

공통 요소를 한 번만 선언해놓고 사용하도록 설계한다.

1. 타입이다.<br>
   클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
   해당 클래스 타입으로 변수를 선언해야 한다.

2. 주어이다.<br>
   Monkey.eat("바나나");<br>
   원숭이가 먹는다 바나나를

#### 클래스 선언

```
	class 클래스명 {
		필드(변수, 메소드)
	}
```

#### 클래스의 필드 사용

객체화(instance): 객체(instance variable)를 만드는 작업, 추상적인 개념을 구체화시키는 작업.<br>

`클래스명 객체명 = new 생성자();`<br>
※ .(마침표): 하위 연산자, 멤버변수 접근 연산자, 닷 연산자, 점 연산자<br><br>
주소값 뒤에서만 사용이 가능하며, 해당 주소를 참조(접근)하는 명령어이다.

#### 생성자

클래스 이름 뒤에 소괄호가 있는 형태, <br>
메소드와 기능이 똑같지만 메소드라고 부르지 않는다.<br>
생성자는 리턴이라는 기능이 존재하지 않기 때문이다.

1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다.
2. 초기화

#### 기본 생성자

매개변수가 없는 생성자이며, 클래스 선언 시 컴파일러가 자동으로 작성해준다.<br>
만약 직접 생성자를 선언하게 되면, 더 이상 컴파일러가 작성해주지 않는다.

#### this

필드에 접근한 객체가 누군지 알아야 해당 필드에 접근할 수 있다.<br>
이 때 접근한 객체가 가지고 있는 필드의 주소값이 this라는 변수에 자동으로 담긴다.

#### 다형성(Polymorphism)

1. 오버 로딩(Overloading)<br>
   매개변수의 개수 혹은 타입이 다르면 동일한 이름의 메소드로 선언할 수 있다.

2. 배열과 클래스의 차이점<br>
   배열은 같은 자료형만 담을 수 있으며, 각 방을 번호(index)로 기억해야 한다.<br>
   순서가 있어야하는 것 또는 처음부터 끝까지가 가져오는 작업이라면 배열에 담는 것이 좋다.<br>
   클래스는 서로 다른 자료형도 담을 수 있으며, 각 값은 전부 이름을 붙여서 필드로 구성한다.<br>
   원하는 값을 가져오고 싶다면, 클래스로 가져오는 것이 훨씬 낫다.

---

#### 상속(Inheritance)

1. 기존에 선언된 클래스의 필드를 다른 클래스의 필드로 사용하고자 할 때
2. 여러 클래스 선언 시 필드가 겹치면 공통 필드로 묶고자 할 때

#### 상속 문법

```
	class A {
		A 필드
	}

	class B extends A{
		A, B 필드
	}
```

A: 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스<br>
B: 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

#### super(): 부모 생성자

자식 클래스 타입의 객체는 부모 필드에 접근할 수 있다.<br>
하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당 된다.<br>
그렇기 때문에 B 타입의 객체로 A 필드인 부모 필드에 접근할 수 없어야 정상이다.<br><br>
사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출 시 부모와 자식 필드 모두 메모리에 할당된다.<br>
이 때, 부모 생성자를 호출하는 방법은 super()를 사용하는 것이다.<br> 만약 super()를 작성하지 않더라도 컴파일러가 자동으로 작성해 준다.<br>
만약 직접 super()를 작성한다면 부모 생성자가 먼저 호출되어야 하기 때문에 영역의 최상단에 작성해야 한다.

#### 다형성(Polymorphism)

1. 오버 로딩
2. 오버라이딩(Overriding)<br>
   부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의 한다.<br>
   같은 이름의 메소드로 선언하면, 자식 객체로 접근했을 때 가까운 곳에서 찾기 때문에 자식 필드에서 재정의된 메소드가 사용된다.<br>
   이 때 부모의 메소드를 사용하고 싶다면, 재정의한 메소드 안에서 super로 접근할 수 있다.

---

### 모든 자식은 부모 타입이다.

#### Casting

구현되지 않은 메소드가 있다면 메모리에 올릴 수 없다.

1. up casting

-   자식 값을 부모 타입으로 형변환

`부모 객체 = new 자식생성자();`

2. down casting

-   up casting된 객체를 다시 자식 타입으로 형변환

`(자식 클래스)up casting된 객체`

※ 부모 값을 자식 타입으로 형변환 시 오류 발생

#### 타입 검사

instanceof<br>

객체 instanceof 타입<br>

1. 같은 자료형이면 true
2. 다른 자료형이면 false

#### Casting을 잘 사용하는 방법

모든 자식들을 하나의 타입으로 묶을 때 up casting을 진행한다.<br>
전달받은 자식 객체가 어떤 타입인지 검사한 뒤 해당 타입으로 down casting을 진행한다.<br>
즉, 묶어서 하나의 타입으로 받고, 다시 원래 타입으로 복구하자!

#### 접근 권한 제어자(접근자)

1. default: 다른 패키지에서 접근 불가
2. public: 모든 곳에서 접근 가능, 만약 클래스 앞에 붙인다면 메인 클래스를 의미한다.
3. protected: 다른 패키지에서 접근 불가, 자식은 가능
4. private: 다른 클래스에서 접근 불가, 메소드로 접근하라는 의미로 사용한다.

※ private 필드는 getter와 setter를 만들자!

---

#### 추상 클래스

필드 안에 구현이 안 된 메소드가 선언되어 있는 클래스를 추상 클래스라고 한다.<br>
이 때 구현되지 않은 메소드를 추상 메소드라고 부른다.<br>
즉, 추상 클래스에 추상 메소드를 선언할 수 있다.<br><br>
이는 반드시 구현해야 하기 때문에 "강제성"을 부여할 수 있다.

#### 추상 클래스 선언

```
abstract class 클래스명 {
	abstract 리턴타입 메소드명(매개변수, ...);
	일반 메소드도 선언 가능하다.
}
```

#### 인터페이스(틀)

-   추상 클래스를 고도화시킨 문법, 상수와 추상 메소드만 존재한다.<br>
    구현은 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는 implements 키워드를 사용한다.

#### 추상 클래스와 인터페이스 간의 관계

인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되기 때문에 전부 다 구현해야 한다.<br>
하지만 일반적인 상황에서는 필요한 메소드를 골라서 재정의한다.<br>
따라서 인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 구현해 놓는다면, 강제성이 소멸되고 이로 인해 골라서 재정의할 수 있게 된다.<br><br>
이 때 중간에서 강제성을 없애주는 클래스를 추상 클래스로 선언하기로 하며, 추상 클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다.<br>

#### 내부 클래스(Inner class)

-   어떤 영역 안에 클래스가 선언되면 내부 클래스라고 한다.

#### 익명 클래스(Anonymous Inner Class)

-   이름이 없는 클래스이며, 구현되지 않은 필드를 구현하기 위해서 일회성으로 생성되는 클래스이다.

---

#### 함수형 인터페이스(Functional Interface)

인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
이 때 @FunctionallInterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언하도록 한다.

#### 람다식(Lambda Expression)

함수형 인터페이스에서는 한 개의 추상 메소드만 존재하기 때문에 구현 시 메소드 이름이 딱히 필요가 없다.<br>
람다식은 이름이 없는 메소드로서, 값처럼 사용이 가능하고 당연히 매개변수로도 전달이 가능하다.<br>
따라서 람다식을 익명 메소드라고도 부른다.

```
람다식 문법
1. (매개변수 형식 나열, ...) -> 리턴값;
2. (매개변수 형식 나열, ...) -> {실행할 문장; return 리턴값;};
3. 매개변수 -> 리턴값; 4. 매개변수 -> {실행할 문장; return 리턴값;};
```

---

#### 예외 처리

에러: 심각한 오류<br>
예외: 덜 심각한 오류

컴파일 시, 빌드 시, 런타임 시 오류가 발생하면 제어문 혹은 문법 교정을 통해 막을 수 있지만 아예 막을 수 없는 상황도 발생한다.<br> 컴퓨터에 이상이 생길 정도로 심각한 오류는 에러라고 표현하고
프로그램에 이상이 생긴 것을 예외라고 부른다.<br>
하지만 정해진 용어는 정확히 없으니 보통 "오류"라고 부른다.<br><br>
프로그램이 강제 종료되는 것을 막는 게 예외 처리의 목적이다.

#### 예외 처리 문법

```
	try {
		오류가 발생할 수 있는 문장;

	}
	catch(예외이름 객체명) {
		오류 발생 시 실행할 문장;
	}
	catch(예외이름 객체명) {
		오류 발생 시 실행할 문장;
	}
	...
	finally {
		catch에서 잡히지 않은 오류가 있더라도 무조건 실행
	}
```

---

#### API(Application Programming Interface)

개발에 필요한 라이브러리들의 집합.
선배 개발자들이 만들어 놓은 소스코드의 집합.

-   내부 API<br>
    JDK 설치 시 제공해주는 기본 API

-   외부 API<br>
    선배 개발자들이 개발한 패키지 및 클래스들을 의미한다.<br>
    보통 JAR파일로 배포하며 자바 프로젝트의 build path에 추가하여 사용할 수 있다.

#### JAR 파일로 배포하기

```
배포할 클래스 또는 패키지 우클릭 > Export > JAVA/JAR file 선택 > Next > destination을 원하는 경로로 선택 > Export Java source files... 체크 > Finish
```

#### JAR 파일을 프로젝트에 추가하기

```
배포된 JAR파일을 다운 받기 > 프로젝트 우클릭 > Build Path > Configure Build Path > Libraries 탭 클릭 > ClassPath(안되면 ModulePath) 클릭 > Add External JARs > 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply and Close
```

---

#### Object 클래스

최상위 부모 클래스로서, 모든 클래스는 자동으로 Object를 상속받는다.

1.  toString()<br>
    항상 객체명을 출력할 때에는 toString()을 붙여서 출력해준다.<br>
    따라서 객체명만 출력 메소드에 전달하더라도 toString()의 문자열 값이 출력된다.<br><br>
    기본적으로 Object에 선언된 toString()은 소속과 필드 주소를 문자열로 리턴해주지만, 실사용에서는 불필요한 정보이기 때문에, 재정의 후 필드의 정보를 확인하도록 구현한다.<br><br>
    실무에서는 클래스 선언 시 각 필드의 초기화 여부를 확인할 때 toString()을 재정의하여 사용한다.
2.  equals()<br>
    주소값을 비교하는 메소드이며 ==과 동일하다.<br>
    String 클래스에서 equals()를 값 비교로 재정의하여 사용하기 때문에
    문자열 비교는 무조건 equals()로 사용한다.<br>
    만약 주소 비교가 아닌 원하는 필드의 비교가 필요하다면 반드시 equals()를 재정의해서 사용해야 한다.

3.  hashCode()<br>
    JVM에서 관리하는 중복 없는 값으로, 실제 메모리에 할당되는 주소와 다르다.<br><br>
    ※ 컬렉션 프레임워크 챕터에서 재정의 목적을 이해하도록 한다.

---

#### Wrapper Class

기본 자료형들의 클래스 타입.

```
클래스타입 객체 = new 클래스타입(일반타입의 값);
클래스타입 객체 = 클래스타입.valueOf(일반타입의 값);
일반타입 변수 = 객체.000Value();
```

---

#### 알고리즘

어떤 문제가 발생되었을 때 해결할 수 있는 절차 혹은 순서.

#### 자료구조(저장소)

의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합.<br>
저장소의 종류에 대해 알아보고 목적과 상황에 맞게 골라 사용하자!

#### Collection Framework(컬렉션 프레임워크)

많은 데이터를 쉽고 효과적으로 관리할 수 있는 자료구조 클래스들의 집합.

#### List extends Collection

List는 인터페이스이다. List를 구현한 클래스들은 아래와 같다.

    1. Vector: 용량 관리, 보안성 강화
    2. LinkedList: 넣을 때는 빨라도 원하는 위치의 데이터를 가져오는 것이 상대적으로 느리다.
    3. ArrayList: 인덱스로 데이터를 관리한다. 컬렉션 클래스 중 실무에서 가장 많이 사용되는 클래스이다.
    		배열의 특징인 인덱스를 이용하여 값을 저장하고 관리한다.(몇개의 데이터를 쓸지 모를 때 사용)

    ※ 배열과 ArrayList의 차이
    		배열은 길이에 제한을 두어야 할 떄 자주 사용되고,
    		ArrayList는 몇 개의 데이터가 들어오는지 알 수 없을 때 사용한다.

---

#### Set(집합)

Set은 인터페이스이다. Set을 지정받아 구현한 대표적인 클래스는
HashSet이다. List와 마찬가지로 Collection 인터페이스를 상속받은 인터페이스이다.

#### HashSet

집합에서 중복되는 원소를 포함할 수 없는 것처럼 HashSet이라는 자료구조는 중복된 값을 무시한다.<br>
저장된 값들은 순서가 없기 때문에 저장된 값들은 가져다 쓸 수 없다.<br>
값의 유무 검사에 특화되어 있는 자료구조이며, 해시코드를 사용하여 검사하기 때문에 속도가 상대적으로 빠르다.

#### Iterator

순서가 없는 객체에 순서를 부여하거나, 순서가 있어도 Iterator방식의 순서로 변경할 때 사용한다.<br>
이 때 해당 객체에 iterator() 메소드를 사용하고, 이 메소드의 리턴 타입은 Iterator 타입이다.<br>
hasNext()를 사용하면 다음 값이 있는지 검사할 수 있고 없다면 false이다.<br>
next()를 사용하면 다음 값을 가져올 수 있다.

---

#### Map

Set과 Collection 2개의 자료구조를 하나로 합친 자료구조이다.<br>
List와 Set처럼 Collection을 상속받지 않았고, 독립적인 자료구조이다.

#### HashMap(서버 간 데이터 교환)

Key와 Value, 한 쌍으로 저장되며, 검색의 목적을 가지고 있다.<br>
Key에 중복된 값을 넣으면, Value가 최근 값으로 수정되고,
중복되지 않은 값을 넣으면 새롭게 추가된다.<br>
단, Value는 중복을 허용한다.

---

#### 프로그램

실행이 안된 상태.

#### 프로세스

실행중인 프로그램.

#### 쓰레드

프로세스 내의 작업 처리 경로.

-   싱글 쓰레드(단일 쓰레드)<br>
    처리 경로를 한 개만 가지고 있기 때문에 직렬적이다.<br>
    한 번에 하나씩 처리하기 때문에 상대적으로 비효율적이다.<br>
    하지만 하나의 작업에 문제가 발생하더라도 다른 작업은 시작하지 않았기 때문에 다른 작업에는 문제가 발생하지 않는다.<br>
    따라서 안정성이 보장된다.
    또한 멀티 쓰레드에 비해 설계가 쉽다.

-   멀티 쓰레드(다중 쓰레드)<br>
    하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례로 처리한다.<br>
    여러 개의 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다.<br>
    하나의 쓰레드 문제 발생 시 모든 쓰레드에 문제가 발생하게 된다.<br>
    멀티 쓰레드로 설계한다면, 처리량 증가, 효율성 증가, 처리비용 감소의 장점이 있기 때문에 이러한 단점을 감수하고 설계하는 편이다.

---

#### 멀티 쓰레드 구현 방법

핵심: run() 메소드 재정의

1. Thread 클래스 상속
2. Runnable 인터페이스 구현

---

#### 동기화(Synchronized)

하나의 쓰레드가 자원에 접근 중일 떄 다른 쓰레드가 동시에 같은 자원을 접근하지 못하게 막는 것.<br>
즉, 자원 공유 문제를 해결할 수 있고 각 쓰레드를 제어해야 할 때에도 자주 사용된다.

동기화 문법 - 블록

```
synchronized(mutex) {
...
}
```

영역 전체에 동기화가 걸린다.

-   키워드<br>
    `synchronized`<br>
    메소드 리턴 타입 앞에 작성하면 해당 메소드가 전체 동기화에 걸린다.

---

#### 파일 입출력

Stream이라는 연결통로를 통해 원본 데이터가 알맞은 인코딩 방식으로 전송된다.<br>
byte 단위로 입출력되기 때문에 개별처리이며, 상세 연산이 필요하지 않다면
Buffer를 사용한 입출력을 권장한다.<br>
Buffer를 사용하면 일괄처리가 가능해진다.

### Writer(출력)

#### BufferedWriter

버퍼를 사용하는 출력 클래스

#### FileWriter

전달한 경로의 파일을 출력의 목적으로 열어준다.<br>
전달한 경로에 파일이 없다면 새롭게 만든 후 열어준다.

### Read(입력)

#### BufferedReader

버퍼를 사용하는 입력 클래스

#### FileReader

전달한 경로의 파일을 입력의 목적으로 열어준다.<br>
전달한 경로에 파일이 없다면 FileNotFoundException이 발생한다.

#### File

전달한 경로에 있는 파일의 정보를 담는 타입.<br>
디렉터리 생성, 해당 경로의 전체 파일

---

### JDBC(Java Database Connectivity)

Java와 RDB간의 연결을 위한 기술

#### 소프트웨어 디자인 설계 패턴

#### ▶ MVC 패턴

M(Model):<br>
테이블에서 조회된 결과 값을 담기 위한 변수들이 선언된 클래스.

-   클래스명 뒤에 VO 또는 DTO라는 문자열을 붙여준다.
-   VO(Value Object): 테이블을 보고 그대로 만든 객체, 단일 테이블 조회
-   DTO(Data Transfer Object): 화면에 결과를 한 번에 묶어서 전달할 객체, 여러 테이블 조회

V(View):<br> 사용자에게 보여질 화면을 구성하는 부분<br>

C(Controller):<br>
JSP 챕터에서 이해할 수 있다.

-   Controller에 작성된 코드가 길어질 수 밖에 없다.<br>
    이 때문에 Controller에서 작성한 코드 중 DBMS SQL문 관련 코드를 분리하기로 한다.<br>
    이렇게 분리한 SQL문 관련코드는 DAO라는 클래스에 분리한다.<br><br>
    DAO는 Data Access Object의 축약어이다.
-   조회 결과는 보통 VO 또는 DTO에 담겨서 리턴된다.
