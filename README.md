# study-java

## Java-Study

JAVA - 프로그래밍 언어<br>

-   프로그래밍 언어는 개발자와 운영체제가 소통하기 위한 언어이다.

소스코드<br>

-   명령어를 작성해 놓은 것.<br>
    개발자와 운영체제가 소통할 것을 글로 작성해 놓은 것.

소스파일(.java)<br>

-   소스코드를 작성해 놓은 파일

컴파일<br>

-   사람의 언어를 컴퓨터 언어로 바꿔주는 작업.

컴파일러<br>

-   컴파일을 해주는 프로그램 또는 명령어<br>
    컴파일러는 위에서 아래로, 좌에서 우로 번역한다.

프로그램<br>

-   소스코드로 잘 짜여진 틀.

콘솔<br>

-   개발자와 운영체제가 소통한 결과를 보여주는 창.

▶ 일반 프로그램<br>

프로그램<br>

-   OS(운영체제): 하드웨어에 적절한 전기신호를 흘려주는 역할.
    하드웨어

▶ JAVA 프로그램<br>

JAVA 프로그램

-   JVM: JAVA 프로그램을 OS에 맞게 변환해준다.
-   OS(운영체제): 하드웨어에 적절한 전기신호를 흘려주는 역할. 하드웨어

-이식성이 좋다.

---

JVM(Java Vritual Machine)

-   JAVA 프로그램을 실행해 줌.

JRE(Java Runtime Environment)

-   JVM을 생성하며, 실행할 때 필요한 라이브러리 파일들을 가지고 있다.

JDK(Java Development Kit)

-   JRE 외에 개발에 필요한 도구들을 가지고 있다.<br>
    컴파일 명령어와 실행 명령어를 담고 있다.

---

> JDK 설치

    https://drive.google.com/file/d/1bsLuMXWQ-yg50m4SNToucnhEBMLSg6He/view?usp=drive_link

> IDE 설치

    - 이클립스
    	https://drive.google.com/file/d/18qYUbfdkXWrX0hbSnvFOuihh9MXI_k7j/view?usp=drive_link

---

#### 기본 구조

    프로젝트
    	패키지
    		클래스
    			메소드
    				소스코드

---

#### 출력 메소드

    1. print(): 마지막에 자동으로 줄바꿈되지 않고 아래 문장과 이어서 출력된다.
    2. println(): 마지막에 자동으로 줄바꿈된다.
    3. printf()

출력 메소드를 사용하는 이유<br>
데이터를 확인하기 위해서 사용하는 도구이다.<br>
오류를 구체화하기 위해 사용하는 도구이다.<br>
즉, 출력 메소드는 개발자를 위한 도구이다.

    A 코드
    B 코드
    C 코드
    D 코드

오류 발생시 어떤 라인에서 발생했는 지 알 수 없다.

    A 코드
    System.out.println("A")
    B 코드
    System.out.println("B")
    C 코드
    System.out.println("C")
    D 코드
    System.out.println("D")

C가 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에 D 코드에 문제가 발생한 것으로 판단된다.

---

#### 변수

변수는 저장공간이다.

    x	        =	       10
    저장공간	대입	값(상수)
    이름	    연산자

#### 자료형(type)

자료형은 저장공간의 종류이다.

```
자료형		type		byte		값

정수형		byte		1		4, 1, -12, 10, ...
		    short		2		9, 150, -55 ...
			int		    4		1235, 48916, -2147483648, ...
			long		8		15161848964L, -489415L, ...

실수형		float		4		32.12F, 182.2341F, ...
			double		8		32.12, 182.2341, ...
문자형		char		2		'A', '0', '안', ...
문자열		String		???		"ABC", "12.52", "123", "안녕", ...
```

#### 변수의 선언

자료형 변수명 = 초기값; ◀ 초기화<br>
자료형 변수명;

    예)
    int x = 10;
    x라는 이름의 정수형 저장공간이 할당(allocation)되고 그 안에 10이 들어간다.

#### 변수의 초기값

```
정수: 0
실수: 0.0
문자: ' '
문자열: "", null
```

#### 변수의 사용

저장공간의 확인 단계<br>
1단계: 자료형을 확인한다.<br>
2단계: 대입 연산자를 확인한다.

    int data = 10;	// 저장공간
    data + 9;		// 값
    data = data + 99	// 저장공간, 값

#### 변수 선언 시 주의사항

1. 같은 이름의 변수로 선언할 수 없다.
2. 초기화를 해준다.
3. 되도록 선언부에 한꺼번에 선언한다(영역 상단).

#### 변수명 주의사항

1.  문자로 시작해야 한다.
2.  특수문자를 사용할 수 없다. 단, \_는 허용한다.
3.  소문자로 시작한다.
4.  공백을 사용할 수 없다.
    good boy
    good_boy: 언더바 표기법
    goodBoy: 카멜 표기법
5.  되도록 한글을 사용하지 않는다.
6.  명사로 사용한다.
7.  뜻이 있는 단어를 사용한다.

        a, b, c, d, e, f, ... (X)
        number, num, data, age, name, ... (O)

#### 변수를 사용하는 이유

1. 반복되는 값을 쉽게 관리하기 위해서
2. 의미 없는 값을 하나의 정보로 만들기 위해서(자료구조)

---

#### 상수

-항상 그대로인 수.<br>
값을 변경할 수 없도록 한다.

`final 자료형 상수명 = 값;`

#### 상수를 사용하는 이유

-   값에 의미부여를 하기 위해서

---

#### 형변환

-   자동 형변환<br>
    정수 + 정수 = 정수<br>
    정수 + 실수 = 실수<br>
    정수 + 문자 = 정수

```
3 + 0.0 = 3.0
10 / 3 = 3
10 % 3 = 1
'A' + 3 = 68
```

-   강제 형변환

```
(자료형)값
(double)3
```

#### 문자열 형변환

1. 다른 자료형을 문자열로<br>
   문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.

2. 문자열을 다른 자료형으로<br>
   일반 자료형은 일반 자료형끼리만 형변환이 가능하다.<br>
   문자열 타입은 클래스 타입이므로, 일반 자료형의 클래스 타입의 도움을 받아야 한다.

```
Integer.parseInt("") => 문자열에서 변환(추출)된 정수
Double.parseDouble("") => 문자열에서 변환(추출)된 실수
```

---

#### 배열:

저장공간의 나열

1. 변수를 여러 개 선언하면 이름도 여러 개 생긴다.<br>
   이 때 각 저장공간을 관리하기 불편하다.<br>
   따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고, 이름도 한 개이기 때문에
   관리하기 편하다.
2. 규칙성이 없는 값에 규칙성을 부여하기 위해서

#### 배열의 선언

자료형[] 배열명 = {값1, 값2, ... }; // 어떤 값을 넣을지 알 때 사용한다.<br>
자료형[] 배열명 = new 자료형[칸수]; // 어떤 값을 넣을지는 모르나, 몇 칸 만들지는 알 때 사용한다.<br>
자료형[] 배열명 = null; // 어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용한다.

```
※ new: Heap 메모리에 할당, 초기값으로 자동 초기화
※ null: 주소의 초기값, 어떤 주소를 넣을지 모를 때 작성하는 값
※ 자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적 배열만 존재한다.
```

#### 배열의 구조

`int[] arData = {3, 5, 1, 2, 8};`

arData라는 이름의 저장공간 한 개 만들어지며, <br>
여기에는 한 개의 값만 담을 수 있다.<br>
<br>
5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다.<br>
5칸의 저장공간 중 첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며,<br>
다음 주소에 접근하기 위해서는 + n을 한다.<br>
<br>
예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며, <br>
\*(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다.<br>
JAVA에서는 직접 주소에 접근하는 연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용한다.<br>
arData[2]로 사용한다. 각각의 방 번호는 index라고 부르며, 시작주소를 가지고 있기 때문에
인덱스 번호는 항상 0부터 시작된다.

#### length

-   배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.<br>
    `배열명.length`

#### 배열의 사용

    int[] arData = new int[5];		    // 저장공간
    arData[0] = 120;			        // 저장공간
    arData[0] + 9;			            // 값
    System.out.println(arData);		    // 주소값
    arData[2] = arData[0] + arData[1];	// 저장공간, 값
    System.out.println(arData[5]);		// 오류

---

#### 2차원 배열:

배열 안에 배열<br><br>
1차원 배열을 여러 개 선언하면, 관리하기 어렵다.<br>
2차원 배열을 한 번만 선언하자!

※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

#### 2차원 배열 선언
```
자료형[][] 배열명 = {{값1, 값2, ...}, {값3, 값4, ...}};
자료형[][] 배열명 = new 자료형[행][열];
자료형[][] 배열명 = null;
```
```
    int[][] arrData = new int[2][3];

    □		arrData		arrData.length: 행의 길이
    □□		arrData[행]	arrData[행].length: 열의 길이
    □□□ □□□	arrData[행][열]
```
---
### 클래스(반)
공통 요소를 한 번만 선언해놓고 사용하도록 설계한다.

1. 타입이다.<br>
클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
해당 클래스 타입으로 변수를 선언해야 한다.

2. 주어이다.<br>
Monkey.eat("바나나");<br>
원숭이가 먹는다 바나나를

#### 클래스 선언
```
	class 클래스명 {
		필드(변수, 메소드)
	}
```

#### 클래스의 필드 사용
객체화(instance): 객체(instance variable)를 만드는 작업, 추상적인 개념을 구체화시키는 작업.<br>

`클래스명 객체명 = new 생성자();`<br>
※ .(마침표): 하위 연산자, 멤버변수 접근 연산자, 닷 연산자, 점 연산자<br><br>
주소값 뒤에서만 사용이 가능하며, 해당 주소를 참조(접근)하는 명령어이다.

#### 생성자
클래스 이름 뒤에 소괄호가 있는 형태, <br>
메소드와 기능이 똑같지만 메소드라고 부르지 않는다.<br>
	생성자는 리턴이라는 기능이 존재하지 않기 때문이다.

1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다.
2. 초기화

#### 기본 생성자
매개변수가 없는 생성자이며, 클래스 선언 시 컴파일러가 자동으로 작성해준다.<br>
만약 직접 생성자를 선언하게 되면, 더 이상 컴파일러가 작성해주지 않는다.

#### this
필드에 접근한 객체가 누군지 알아야 해당 필드에 접근할 수 있다.<br>
이 때 접근한 객체가 가지고 있는 필드의 주소값이 this라는 변수에 자동으로 담긴다.	

#### 다형성(Polymorphism)
1. 오버 로딩(Overloading)<br>
		매개변수의 개수 혹은 타입이 다르면 동일한 이름의 메소드로 선언할 수 있다.

2. 배열과 클래스의 차이점<br>
	배열은 같은 자료형만 담을 수 있으며, 각 방을 번호(index)로 기억해야 한다.<br>
	순서가 있어야하는 것 또는 처음부터 끝까지가 가져오는 작업이라면 배열에 담는 것이 좋다.<br>
	클래스는 서로 다른 자료형도 담을 수 있으며, 각 값은 전부 이름을 붙여서 필드로 구성한다.<br>
	원하는 값을 가져오고 싶다면, 클래스로 가져오는 것이 훨씬 낫다.
